//  Auth - Account Controller.swift
//  TimeSelfCare
//
//  Generated by Operahouse using Auth - Account Controller
//  Template last updated 2017-10-17
//  Copyright Â© 2017 Apptivity Lab. All rights reserved.
//

import UIKit
import ApptivityFramework

public extension NSNotification.Name {
    static let SelectedAccountDidChange: NSNotification.Name = NSNotification.Name(rawValue: "SelectedAccountDidChange")
}

public let sessionIdKey = "sessionIdKey"

public class AccountController {
    private static let singleton: AccountController = AccountController()
    public static var shared: AccountController {
        return AccountController.singleton
    }

    public var selectedAccount: Account? {
        didSet {
            if selectedAccount != nil {
                NotificationCenter.default.post(name: NSNotification.Name.SelectedAccountDidChange, object: nil)
            }
        }
    }

    public var sessionId: String? {
        return Installation.current().valueForKey(sessionIdKey) as? String
    }

    public var needUpdateEmailAddress: Bool {
        get {
            return Installation.current().valueForKey("needUpdateEmailAddress") as? Bool ?? false
        }
        set(value) {
            Installation.current().set(value, forKey: "needUpdateEmailAddress")
        }
    }

    public var profile: Profile! { // swiftlint:disable:this implicitly_unwrapped_optional
        return AuthUser.current?.person as? Profile
    }

    init() {
        NotificationCenter.default.addObserver(self, selector: #selector(self.applicationDidBecomeActive), name: UIApplication.didBecomeActiveNotification, object: nil)
    }

    @objc
    public func applicationDidBecomeActive() {
        guard self.profile != nil else {
            return
        }

        // what do you want to do when the app launches?
    }
}

// MARK: - IdentityFramework: AuthUserDelegate
extension AccountController: AuthUserDelegate {
    public func identityDelegate(for identityType: IdentityType) -> IdentityDelegate? {
        switch identityType {
        case .userpass, .email:
            return self
        default:
            return nil
        }
    }

    public func logoutUser(completion: @escaping () -> Void) {
        self.API.logout { (_, error: Error?) in
            if let error = error {
                debugPrint("Logout error: \(error)")
            }
            if let notificationSetting = NotificationSettingDataController.shared.getNotificationSettings(account: AccountController.shared.selectedAccount).first {
                notificationSetting.deviceToken = String()
                APNSController.shared.deleteAllNotifications()
                UIApplication.shared.applicationIconBadgeNumber = 0
                NotificationSettingDataController.shared.updateNotificationSetting(notificationSetting: notificationSetting)
            }

            self.needUpdateEmailAddress = false
            self.selectedAccount = nil
            completion()
        }
    }

    public func resetPassword(with identifier: String, completion: ((_ error: AuthError?) -> Void)?) {
        // No-op: We're going to use a WebView for that :)
    }
}

// MARK: - IdentityFramework: IdentityDelegate
extension AccountController: IdentityDelegate {
    public func addIdentity(_ identity: Identity, for user: AuthUser, completion: ((Identity?, AuthError?) -> Void)?) {
        guard let timeSelfCareIdentity = identity as? TimeSelfCareIdentity else {
            completion?(identity, AuthError.invalidIdentity)
            return
        }
    }

    public func resendActivationCode(for identity: Identity, completion: AuthUser.CompletionBlock?) {
    }

    public func authenticate(using identity: Identity, completion: ((Identity?, AuthError?) -> Void)?) {
        self.API.loginWithEmail(identity.identifier, password: identity.challenge) { (_, error: Error?) in
            completion?(identity, self.authErrorFrom(error))
        }
    }

    public func activateIdentity(_ identity: Identity, for user: AuthUser, withCode: String, completion: AuthUser.CompletionBlock?) {

    }

    public func savedIdentity(with data: Data, belongingToUser user: AuthUser) -> Identity? {
        if let identity = TimeSelfCareIdentity(data: data) {
            return identity
        }
        return nil
    }

    public func validateInput(for identity: Identity) -> Bool {
        return identity.identifier.isEmail && !identity.challenge.isEmpty
    }

    public func removeIdentity(_ identity: Identity, for user: AuthUser, completion: ((_ error: AuthError?) -> Void)?) {

    }

    public func updateIdentity(_ identity: Identity, for user: AuthUser, completion: ((_ error: AuthError?) -> Void)?) {

    }

    public func resendChallenge(for identity: Identity, completion: AuthUser.CompletionBlock?) {

    }

    // Check with external server to see if challenge phrase matches identity
    public func verifyIdentity(_ identity: Identity, with challenge: String?, for user: AuthUser, completion: ((_ success: Bool, _ error: AuthError?) -> Void)?) {

    }

    public func changeChallenge(for identity: Identity, from challenge: String, to newChallenge: String, completion: ((_ error: AuthError?) -> Void)?) {

    }

    private func authErrorFrom(_ error: Error?) -> AuthError? {
        if let error = error {
            if let errorCode = (error as NSError).userInfo[TimeSelfCareDomainErrorCodeKey] as? String {
                switch errorCode {
                case "INVALID_IDENTIFIER_OR_CHALLENGE":
                    return AuthError.invalidCredentials
                case "IDENTITY_TAKEN":
                    return AuthError.identityTaken
                default:
                    return AuthError.unknown(message: nil)
                }
            }

            return AuthError.unknown(message: nil)
        }

        return nil
    }
}

// MARK: - IdentityFramework: PersonDelegate
extension AccountController: PersonDelegate {
    public func profileForUser(_ user: AuthUser) -> Person? {
        guard let jsonDataFromKeychain = Data.fromKeychain(service: Bundle.main.bundleIdentifier ?? "TimeSelfCare", withKey: "profile") else {
            return nil
        }

        do {
            if let profileJSON = try JSONSerialization.jsonObject(with: jsonDataFromKeychain, options: JSONSerialization.ReadingOptions(rawValue: 0)) as? [String : Any] {
                return Profile(with: profileJSON)
            }
        } catch {
            debugPrint("Error while instantiating Profile from Keychain: \(error)")
        }

        return nil

    }

    public func user(_ user: AuthUser, didUpdateProfile profile: Person?) {
        guard let userProfile: Profile = profile as? Profile else {
            if !Keychain.delete(key: "profile", inService: Bundle.main.bundleIdentifier ?? "TimeSelfCare") {
                debugPrint("Unable to delete profile in TimeSelfCare keychain")
            }
            return
        }

        let profileJson = userProfile.toJson()
        do {
            if JSONSerialization.isValidJSONObject(profileJson) {
                let jsonData: Data = try JSONSerialization.data(withJSONObject: profileJson, options: JSONSerialization.WritingOptions(rawValue: 0))
                try jsonData.saveInKeychain(service: Bundle.main.bundleIdentifier ?? "TimeSelfCare", withKey: "profile")
            }
        } catch {
            debugPrint("Error saving profile into Keychain: \(error)")
        }
    }
}
